# Задача по теории вероятностей

# Между двумя берегами реки находятся 6 островов (2 ряда по 3 острова). Между островами и берегами перекинуты мосты. Всего 13 мостов.
# Схема островов и мостов представлена ниже. В случае землетрясения мосты рушатся с вероятностью 1/2. 
# С какой вероятностью человек сможет перейти с берега на берег, если произойдет землетрясение?

# берег
# ------------------------------
# река  |i|     |n|     |s|
#       ---  l  ---  q  ---
#      |   |===|   |===|   |
#       ---     ---     ---
#       |j|     |o|     |t|
#       ---  m  ---  r  ---
#      |   |===|   |===|   |
#       ---     ---     ---
#       |k|     |p|     |u|
# ------------------------------
# берег

# РЕШЕНИЕ 1:

# План решения:
# 1. Посчитаем, сколько всего может быть комбинаций с разрушенными и/или устоявшими мостами после землетрясения.
# 2. Найдем все способы перейти реку и для каждого способа - все возможные комбинации состояний мостов. 
# 3. Так как комбинации могут повторяться между разными способами, то найдём дубли и удалим их. 
# 4. Посчитаем суммарное количество комбинаций после удаления дублей.
# 5. Найдем вероятность перейти реку согласно частотному определению вероятности (количество комбинаций, когда можно перейти реку / суммарное количество комбинаций).

# Посчитаем, сколько всего может быть комбинаций с разрушенными и/или устоявшими мостами после землетрясения.

total_count = 2**13 
print('Количество разнообразных комбинаций с разрушенными и устоявшими мостами:', total_count)

# Перейти с берега на берег, когда все мосты целы, можно 29 способами (10, если начинать с моста i и s, и 9, если начинать с моста n).
# Напишем функцию, которая на вход будет для каждого способа принимать перечень уцелевших мостов и перебирать возможные комбинации состояний оставшихся мостов.
# Пусть 1 означает, что мост цел, и 0, что разрушен.

def list(surv_bridges):
	d = {'i': 0, 'j': 0, 'k': 0, 'l': 0, 'm': 0, 'n': 0, 'o': 0, 'p': 0, 'q': 0, 'r': 0, 's': 0, 't': 0, 'u': 0} 
	for char in surv_bridges:
		d[char] = 1
	list = []
	for i in range(d['i'], 2):
		for j in range(d['j'], 2):
			for k in range(d['k'], 2):
				for l in range(d['l'], 2):
					for m in range(d['m'], 2):
						for n in range(d['n'], 2):
							for o in range(d['o'], 2):
								for p in range(d['p'], 2):
									for q in range(d['q'], 2):
										for r in range(d['r'], 2):
											for s in range(d['s'], 2):
												for t in range(d['t'], 2):
													for u in range(d['u'], 2):
														list.append([i,j,k,l,m,n,o,p,q,r,s,t,u])
	return list 

# Для каждого способа перейти реку найдем все комбинации состояний мостов.

list1 = list(['i', 'j', 'k'])
list2 = list(['i', 'j', 'm', 'p'])
list3 = list(['i', 'j', 'm', 'r', 'u'])
list4 = list(['i', 'j', 'm', 'o', 'q', 't', 'u'])
list5 = list(['i', 'l', 'o', 'p'])
list6 = list(['i', 'k', 'l', 'm', 'o'])
list7 = list(['i', 'l', 'o', 'r', 'u'])
list8 = list(['i', 'l', 'q', 't', 'u'])
list9 = list(['i', 'l', 'p', 'q', 'r', 't'])
list10 = list(['i', 'k', 'l', 'm', 'q', 'r', 't'])
list11 = list(['s', 't', 'u'])
list12 = list(['p', 'r', 's', 't'])
list13 = list(['k', 'm', 'r', 's', 't'])
list14 = list(['j', 'k', 'l', 'o', 'r', 's', 't'])
list15 = list(['o', 'p', 'q', 's'])
list16 = list(['o', 'q', 'r', 's', 'u'])											
list17 = list(['k', 'm', 'o', 'q', 's'])	
list18 = list(['j', 'k', 'l', 'q', 's'])	
list19 = list(['j', 'l', 'm', 'p', 'q', 's'])	
list20 = list(['j', 'l', 'm', 'q', 'r', 's', 'u'])	
list21 = list(['n', 'o', 'p'])	
list22 = list(['j', 'k', 'l', 'n'])	
list23 = list(['j', 'l', 'm', 'n', 'p'])	
list24 = list(['j', 'l', 'm', 'n', 'r', 'u'])
list25 = list(['n', 'q', 't', 'u'])
list26 = list(['n', 'p', 'q', 'r', 't'])
list26 = list(['n', 'p', 'q', 'r', 't'])
list27 = list(['k', 'm', 'n', 'o'])
list28 = list(['k', 'm', 'n', 'q', 'r', 't'])
list29 = list(['n', 'o', 'r', 'u'])

# Списки комбинаций перейти реку имеют пересечения между способами 1-29. 
# Например, в list1 есть комбинации, которые также были посчитаны для list11. И так далее для других списков.
# Поэтому необходимо найти такие пересечения и удалить дубли, чтобы каждая комбинация сохранилась в единственном экземпляре. 
# Для этого напишем функцию, которая будет сравнивать списки между собой и удалять найденные дубли.

def foo(listx, listy):
	for i in range(len(listx)):
		for j in range(len(listy)):
			if listx[i] == listy[j]:
				del listx[i]
				listx.insert(i, 'shit') # добавим элемент, который позволит сохранить нумерацию в списках и который можно будет легко найти в будущем			
	cnt = listx.count('shit')
	for i in range(cnt):
		listx.remove('shit')

# Сделаем сравнение всех списков между собой.

l_of_l = [list1, list2, list3, list4, list5, list6, list7, list8, list9, list10, list11, list12, list13, list14, list15, list16, list17, list18, list19, list20, list21, list22, list23, list24, list25, list26, list27, list28, list29]

for ind1 in range(len(l_of_l) - 1):
	for ind2 in range(ind1 + 1, len(l_of_l)):
		foo(l_of_l[ind1], l_of_l[ind2])

# Найдем суммарное количество комбинаций с разрушенными и/или устоявшими мостами, при которых можно перейти реку (после чистки от дублей).

count_positive = 0
for list in l_of_l:
	count_positive += len(list)

print('Количество комбинаций с разрушенными и/или устоявшими мостами, когда можно перейти реку:', count_positive)

# Найдем вероятность перейти реку согласно частотному определению вероятности (количество комбинаций, когда можно перейти реку / суммарное количество комбинаций).

P = count_positive / total_count
print('Вероятность перейти реку в случае землетрясения:', P)

# РЕШЕНИЕ 2:

# Эту задачу можно решить безо всяких формул и расчетов примерно за 1 минуту. Попробуйте найти это решение.
